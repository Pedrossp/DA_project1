<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Water Supply Management: DataManip Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Water Supply Management
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classDataManip-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DataManip Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a429abd4d3690c231858d63f6e126a8f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a429abd4d3690c231858d63f6e126a8f9">DataManip</a> ()</td></tr>
<tr class="memdesc:a429abd4d3690c231858d63f6e126a8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <a class="el" href="classDataManip.html">DataManip</a> class.  <a href="classDataManip.html#a429abd4d3690c231858d63f6e126a8f9">More...</a><br /></td></tr>
<tr class="separator:a429abd4d3690c231858d63f6e126a8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9627d0b2c670b324ebb0ca0b7a48877"><td class="memItemLeft" align="right" valign="top"><a id="ad9627d0b2c670b324ebb0ca0b7a48877"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#ad9627d0b2c670b324ebb0ca0b7a48877">readCities</a> ()</td></tr>
<tr class="memdesc:ad9627d0b2c670b324ebb0ca0b7a48877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read cities data from a CSV file and populate the data structures. <br /></td></tr>
<tr class="separator:ad9627d0b2c670b324ebb0ca0b7a48877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3a8350362cabf8ecef5e534459fa5c"><td class="memItemLeft" align="right" valign="top"><a id="a6e3a8350362cabf8ecef5e534459fa5c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a6e3a8350362cabf8ecef5e534459fa5c">readStations</a> ()</td></tr>
<tr class="memdesc:a6e3a8350362cabf8ecef5e534459fa5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read stations data from a CSV file and populate the data structures. <br /></td></tr>
<tr class="separator:a6e3a8350362cabf8ecef5e534459fa5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcababcca77e859dc351ec9a15fbb98"><td class="memItemLeft" align="right" valign="top"><a id="a1bcababcca77e859dc351ec9a15fbb98"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a1bcababcca77e859dc351ec9a15fbb98">readReservoirs</a> ()</td></tr>
<tr class="memdesc:a1bcababcca77e859dc351ec9a15fbb98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read reservoirs data from a CSV file and populate the data structures. <br /></td></tr>
<tr class="separator:a1bcababcca77e859dc351ec9a15fbb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3fec35fa93fd52d06d4d30dd2c0a32"><td class="memItemLeft" align="right" valign="top"><a id="aea3fec35fa93fd52d06d4d30dd2c0a32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#aea3fec35fa93fd52d06d4d30dd2c0a32">readPipes</a> ()</td></tr>
<tr class="memdesc:aea3fec35fa93fd52d06d4d30dd2c0a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read pipes data from a CSV file and populate the data structures. <br /></td></tr>
<tr class="separator:aea3fec35fa93fd52d06d4d30dd2c0a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0c8446bd91f640e84e663e9ccf956a"><td class="memItemLeft" align="right" valign="top"><a id="afb0c8446bd91f640e84e663e9ccf956a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#afb0c8446bd91f640e84e663e9ccf956a">readCitiesL</a> ()</td></tr>
<tr class="memdesc:afb0c8446bd91f640e84e663e9ccf956a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read cities data from a CSV file in the large data set and populate the data structures. <br /></td></tr>
<tr class="separator:afb0c8446bd91f640e84e663e9ccf956a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069d61fb7022fda935b17b798600fe74"><td class="memItemLeft" align="right" valign="top"><a id="a069d61fb7022fda935b17b798600fe74"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a069d61fb7022fda935b17b798600fe74">readStationsL</a> ()</td></tr>
<tr class="memdesc:a069d61fb7022fda935b17b798600fe74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read stations data from a CSV file in the large data set and populate the data structures. <br /></td></tr>
<tr class="separator:a069d61fb7022fda935b17b798600fe74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a4e70eb5b41d0d2a90758b4c5d7c77"><td class="memItemLeft" align="right" valign="top"><a id="aa8a4e70eb5b41d0d2a90758b4c5d7c77"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#aa8a4e70eb5b41d0d2a90758b4c5d7c77">readReservoirsL</a> ()</td></tr>
<tr class="memdesc:aa8a4e70eb5b41d0d2a90758b4c5d7c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read reservoirs data from a CSV file in the large data set and populate the data structures. <br /></td></tr>
<tr class="separator:aa8a4e70eb5b41d0d2a90758b4c5d7c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5a639815c2b01e09bc529708e05c94"><td class="memItemLeft" align="right" valign="top"><a id="a2d5a639815c2b01e09bc529708e05c94"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a2d5a639815c2b01e09bc529708e05c94">readPipesL</a> ()</td></tr>
<tr class="memdesc:a2d5a639815c2b01e09bc529708e05c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read pipes data from a CSV file in the large data set and populate the data structures. <br /></td></tr>
<tr class="separator:a2d5a639815c2b01e09bc529708e05c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30197aa1a20963aea0f069cc5824db1"><td class="memItemLeft" align="right" valign="top">map&lt; string, <a class="el" href="classCity.html">City</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#af30197aa1a20963aea0f069cc5824db1">getCitiesC</a> ()</td></tr>
<tr class="memdesc:af30197aa1a20963aea0f069cc5824db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the map of cities by code.  <a href="classDataManip.html#af30197aa1a20963aea0f069cc5824db1">More...</a><br /></td></tr>
<tr class="separator:af30197aa1a20963aea0f069cc5824db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e556e30b43f2b3ce1013aae422a4ac"><td class="memItemLeft" align="right" valign="top">map&lt; string, <a class="el" href="classCity.html">City</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#af1e556e30b43f2b3ce1013aae422a4ac">getCitiesN</a> ()</td></tr>
<tr class="memdesc:af1e556e30b43f2b3ce1013aae422a4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the map of cities by name.  <a href="classDataManip.html#af1e556e30b43f2b3ce1013aae422a4ac">More...</a><br /></td></tr>
<tr class="separator:af1e556e30b43f2b3ce1013aae422a4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b165cac80dfa4b0636b3ff2348efc6"><td class="memItemLeft" align="right" valign="top">map&lt; string, <a class="el" href="classStation.html">Station</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a33b165cac80dfa4b0636b3ff2348efc6">getStations</a> ()</td></tr>
<tr class="memdesc:a33b165cac80dfa4b0636b3ff2348efc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the map of stations.  <a href="classDataManip.html#a33b165cac80dfa4b0636b3ff2348efc6">More...</a><br /></td></tr>
<tr class="separator:a33b165cac80dfa4b0636b3ff2348efc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45db5e2770f3abbbb8a27f0571b66818"><td class="memItemLeft" align="right" valign="top">map&lt; string, <a class="el" href="classReservoir.html">Reservoir</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a45db5e2770f3abbbb8a27f0571b66818">getReservoirs</a> ()</td></tr>
<tr class="memdesc:a45db5e2770f3abbbb8a27f0571b66818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the map of reservoirs.  <a href="classDataManip.html#a45db5e2770f3abbbb8a27f0571b66818">More...</a><br /></td></tr>
<tr class="separator:a45db5e2770f3abbbb8a27f0571b66818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07820ea9a44d26b482cae7d99d05116a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a07820ea9a44d26b482cae7d99d05116a">getGraph</a> ()</td></tr>
<tr class="memdesc:a07820ea9a44d26b482cae7d99d05116a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the graph representing connections between cities, stations, and reservoirs.  <a href="classDataManip.html#a07820ea9a44d26b482cae7d99d05116a">More...</a><br /></td></tr>
<tr class="separator:a07820ea9a44d26b482cae7d99d05116a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f72542e61a848e805e9facdaced082"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a49f72542e61a848e805e9facdaced082">verifyCityCode</a> (string cityCodeOrName)</td></tr>
<tr class="memdesc:a49f72542e61a848e805e9facdaced082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify city code or name.  <a href="classDataManip.html#a49f72542e61a848e805e9facdaced082">More...</a><br /></td></tr>
<tr class="separator:a49f72542e61a848e805e9facdaced082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a732b3be343efce690f5f4b3a37150d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a4a732b3be343efce690f5f4b3a37150d">normalizeGraph</a> ()</td></tr>
<tr class="memdesc:a4a732b3be343efce690f5f4b3a37150d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the graph.  <a href="classDataManip.html#a4a732b3be343efce690f5f4b3a37150d">More...</a><br /></td></tr>
<tr class="separator:a4a732b3be343efce690f5f4b3a37150d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f9351db9892fa07d55431bdaea6588"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a07f9351db9892fa07d55431bdaea6588">findAugmentingPath</a> (<a class="el" href="classVertex.html">Vertex</a> *s, <a class="el" href="classVertex.html">Vertex</a> *t)</td></tr>
<tr class="memdesc:a07f9351db9892fa07d55431bdaea6588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an augmenting path from source 's' to sink 't' in the graph.  <a href="classDataManip.html#a07f9351db9892fa07d55431bdaea6588">More...</a><br /></td></tr>
<tr class="separator:a07f9351db9892fa07d55431bdaea6588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c06df80ae7332913f1b4fb6836ba76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#ac3c06df80ae7332913f1b4fb6836ba76">testAndVisit</a> (queue&lt; <a class="el" href="classVertex.html">Vertex</a> * &gt; &amp;q, <a class="el" href="classEdge.html">Edge</a> *e, <a class="el" href="classVertex.html">Vertex</a> *w, double residual)</td></tr>
<tr class="memdesc:ac3c06df80ae7332913f1b4fb6836ba76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test and visit a vertex.  <a href="classDataManip.html#ac3c06df80ae7332913f1b4fb6836ba76">More...</a><br /></td></tr>
<tr class="separator:ac3c06df80ae7332913f1b4fb6836ba76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1efa509c45144dd686141ddc8899c1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#acb1efa509c45144dd686141ddc8899c1">findMinResidualAlongPath</a> (<a class="el" href="classVertex.html">Vertex</a> *s, <a class="el" href="classVertex.html">Vertex</a> *t)</td></tr>
<tr class="memdesc:acb1efa509c45144dd686141ddc8899c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the minimum residual capacity along an augmenting path from source 's' to sink 't'.  <a href="classDataManip.html#acb1efa509c45144dd686141ddc8899c1">More...</a><br /></td></tr>
<tr class="separator:acb1efa509c45144dd686141ddc8899c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9e44bc0e04fdc88862674e32723d24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#abe9e44bc0e04fdc88862674e32723d24">augmentFlowAlongPath</a> (<a class="el" href="classVertex.html">Vertex</a> *s, <a class="el" href="classVertex.html">Vertex</a> *t, double f)</td></tr>
<tr class="memdesc:abe9e44bc0e04fdc88862674e32723d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Augment flow along an augmenting path from source 's' to sink 't'.  <a href="classDataManip.html#abe9e44bc0e04fdc88862674e32723d24">More...</a><br /></td></tr>
<tr class="separator:abe9e44bc0e04fdc88862674e32723d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83fe0b71e04cce777e18d344bc93719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#aa83fe0b71e04cce777e18d344bc93719">maxFlowEdmonds</a> ()</td></tr>
<tr class="memdesc:aa83fe0b71e04cce777e18d344bc93719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the maximum flow in the graph using the Edmonds-Karp algorithm.  <a href="classDataManip.html#aa83fe0b71e04cce777e18d344bc93719">More...</a><br /></td></tr>
<tr class="separator:aa83fe0b71e04cce777e18d344bc93719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c7207186d8815be3027e57284a2e52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a70c7207186d8815be3027e57284a2e52">maxFLowTotalCity</a> (int choose, string cityCodeOrName)</td></tr>
<tr class="memdesc:a70c7207186d8815be3027e57284a2e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and display the maximum flow of water in the network, either total or for a specific city.  <a href="classDataManip.html#a70c7207186d8815be3027e57284a2e52">More...</a><br /></td></tr>
<tr class="separator:a70c7207186d8815be3027e57284a2e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59818e3e118aac3bfaab48cee367c17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#ab59818e3e118aac3bfaab48cee367c17">getDeficit</a> ()</td></tr>
<tr class="memdesc:ab59818e3e118aac3bfaab48cee367c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and display the deficit of water for each city.  <a href="classDataManip.html#ab59818e3e118aac3bfaab48cee367c17">More...</a><br /></td></tr>
<tr class="separator:ab59818e3e118aac3bfaab48cee367c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011cb1e9a4b50aab60522619cc248659"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a011cb1e9a4b50aab60522619cc248659">getAverageDifference</a> ()</td></tr>
<tr class="memdesc:a011cb1e9a4b50aab60522619cc248659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and display the average difference, maximum difference, and variance between edge capacities and flows.  <a href="classDataManip.html#a011cb1e9a4b50aab60522619cc248659">More...</a><br /></td></tr>
<tr class="separator:a011cb1e9a4b50aab60522619cc248659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ebf28c2b33e8e10acac716f72027f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#aa5ebf28c2b33e8e10acac716f72027f9">BalanceFlow</a> ()</td></tr>
<tr class="memdesc:aa5ebf28c2b33e8e10acac716f72027f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balance the flow across edges in the graph to ensure that the total flow into each vertex matches its total capacity.  <a href="classDataManip.html#aa5ebf28c2b33e8e10acac716f72027f9">More...</a><br /></td></tr>
<tr class="separator:aa5ebf28c2b33e8e10acac716f72027f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a496e4c5a426566b0b73c772ce3f04"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a87a496e4c5a426566b0b73c772ce3f04">verifyReservoirCode</a> (string reservoirNameOrCode)</td></tr>
<tr class="memdesc:a87a496e4c5a426566b0b73c772ce3f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify city code or name.  <a href="classDataManip.html#a87a496e4c5a426566b0b73c772ce3f04">More...</a><br /></td></tr>
<tr class="separator:a87a496e4c5a426566b0b73c772ce3f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d66041356fcca4827a06a3c51e94388"><td class="memItemLeft" align="right" valign="top"><a id="a9d66041356fcca4827a06a3c51e94388"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>stationRemoved</b> (vector&lt; string &gt; sCodes)</td></tr>
<tr class="separator:a9d66041356fcca4827a06a3c51e94388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae69424dd271f8b1e42ad8249d782f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a7ae69424dd271f8b1e42ad8249d782f2">reservoirOutOfCommission</a> (vector&lt; string &gt; codeOrName)</td></tr>
<tr class="memdesc:a7ae69424dd271f8b1e42ad8249d782f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulate the removal of reservoirs from commission.  <a href="classDataManip.html#a7ae69424dd271f8b1e42ad8249d782f2">More...</a><br /></td></tr>
<tr class="separator:a7ae69424dd271f8b1e42ad8249d782f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61719284835fa07882cdaa2885a5171"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#ac61719284835fa07882cdaa2885a5171">pipelineRemoved</a> (vector&lt; pair&lt; string, string &gt;&gt; p)</td></tr>
<tr class="memdesc:ac61719284835fa07882cdaa2885a5171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulate the removal of pipelines.  <a href="classDataManip.html#ac61719284835fa07882cdaa2885a5171">More...</a><br /></td></tr>
<tr class="separator:ac61719284835fa07882cdaa2885a5171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dac7621f6afc001f3afffadcc5549b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a7dac7621f6afc001f3afffadcc5549b7">citiesFlow</a> ()</td></tr>
<tr class="memdesc:a7dac7621f6afc001f3afffadcc5549b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and set the total flow of water into each city.  <a href="classDataManip.html#a7dac7621f6afc001f3afffadcc5549b7">More...</a><br /></td></tr>
<tr class="separator:a7dac7621f6afc001f3afffadcc5549b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a429abd4d3690c231858d63f6e126a8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429abd4d3690c231858d63f6e126a8f9">&#9670;&nbsp;</a></span>DataManip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataManip::DataManip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for <a class="el" href="classDataManip.html">DataManip</a> class. </p>
<p>This constructor initializes a <a class="el" href="classDataManip.html">DataManip</a> object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abe9e44bc0e04fdc88862674e32723d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9e44bc0e04fdc88862674e32723d24">&#9670;&nbsp;</a></span>augmentFlowAlongPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataManip::augmentFlowAlongPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Augment flow along an augmenting path from source 's' to sink 't'. </p>
<p>This function traverses the augmenting path from sink vertex 't' to source vertex 's' and updates the flow values of the edges accordingly. It iterates through the edges along the path and adjusts the flow based on the direction of the edge.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The source vertex of the augmenting path. </td></tr>
    <tr><td class="paramname">t</td><td>The sink vertex of the augmenting path. </td></tr>
    <tr><td class="paramname">f</td><td>The amount by which to augment the flow.</td></tr>
  </table>
  </dd>
</dl>
<p>@complexity Let k be the length of the augmenting path. The function iterates through the edges along the path once, performing constant-time operations at each step. Therefore, the overall time complexity is O(k), where k is the length of the augmenting path. </p>

</div>
</div>
<a id="aa5ebf28c2b33e8e10acac716f72027f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ebf28c2b33e8e10acac716f72027f9">&#9670;&nbsp;</a></span>BalanceFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataManip::BalanceFlow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Balance the flow across edges in the graph to ensure that the total flow into each vertex matches its total capacity. </p>
<p>This function iterates over all vertices in the graph and adjusts the flow across edges to balance it with the total capacity of the vertex. If a vertex represents a reservoir (identified by starting with "R"), it ensures that the total flow into the reservoir does not exceed its maximum delivery capacity.</p>
<p>@complexity The time complexity of this function depends on the number of vertices and edges in the graph. The function iterates through all vertices and their adjacent edges, resulting in a linear-time operation with respect to the number of vertices and edges. Within the nested loops, it performs calculations and adjustments with constant-time complexity. Therefore, the overall time complexity of this function is O(V * E), where V is the number of vertices and E is the number of edges in the graph. </p>

</div>
</div>
<a id="a7dac7621f6afc001f3afffadcc5549b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dac7621f6afc001f3afffadcc5549b7">&#9670;&nbsp;</a></span>citiesFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataManip::citiesFlow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate and set the total flow of water into each city. </p>
<p>This function iterates over all cities in the network and calculates the total flow of water into each city by summing the flow across all incoming edges. It then sets the calculated total flow value for each city.</p>
<dl class="section note"><dt>Note</dt><dd>This function assumes that each city in the network is represented by a vertex in the graph_ member variable. </dd></dl>

</div>
</div>
<a id="a07f9351db9892fa07d55431bdaea6588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f9351db9892fa07d55431bdaea6588">&#9670;&nbsp;</a></span>findAugmentingPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DataManip::findAugmentingPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an augmenting path from source 's' to sink 't' in the graph. </p>
<p>This function searches for an augmenting path from source vertex 's' to sink vertex 't' in the graph using BFS. It marks vertices as visited during the search process and utilizes the 'testAndVisit' function to enqueue vertices to the BFS queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The source vertex of the augmenting path. </td></tr>
    <tr><td class="paramname">t</td><td>The sink vertex of the augmenting path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an augmenting path is found from 's' to 't', otherwise false.</dd></dl>
<p>@complexity The time complexity of this function depends on the size of the graph and the efficiency of the 'testAndVisit' function. Let n be the number of vertices and m be the number of edges in the graph. The function performs a BFS traversal from the source vertex 's' to the sink vertex 't', visiting each vertex and edge at most once. Therefore, the overall time complexity is O(n + m). </p>

</div>
</div>
<a id="acb1efa509c45144dd686141ddc8899c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1efa509c45144dd686141ddc8899c1">&#9670;&nbsp;</a></span>findMinResidualAlongPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DataManip::findMinResidualAlongPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the minimum residual capacity along an augmenting path from source 's' to sink 't'. </p>
<p>This function traverses the augmenting path from sink vertex 't' to source vertex 's' to find the minimum residual capacity. It iterates through the edges along the path and calculates the minimum residual capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The source vertex of the augmenting path. </td></tr>
    <tr><td class="paramname">t</td><td>The sink vertex of the augmenting path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum residual capacity along the augmenting path.</dd></dl>
<p>@complexity Let k be the length of the augmenting path. The function iterates through the edges along the path once, performing constant-time operations at each step. Therefore, the overall time complexity is O(k), where k is the length of the augmenting path. </p>

</div>
</div>
<a id="a011cb1e9a4b50aab60522619cc248659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011cb1e9a4b50aab60522619cc248659">&#9670;&nbsp;</a></span>getAverageDifference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataManip::getAverageDifference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate and display the average difference, maximum difference, and variance between edge capacities and flows. </p>
<p>This function computes the average difference, maximum difference, and variance between the capacities and flows of all edges in the network. It then displays these statistical measures.</p>
<p>@complexity The time complexity of this function depends on the number of vertices and edges in the graph. The function iterates through all edges in the graph to calculate the differences between their capacities and flows, resulting in a linear-time operation. After computing the differences, the function calculates the average and variance, which also have linear-time complexity. Therefore, the overall time complexity of this function is O(V * E), where V is the number of vertices and E is the number of edges in the graph. </p>

</div>
</div>
<a id="af30197aa1a20963aea0f069cc5824db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30197aa1a20963aea0f069cc5824db1">&#9670;&nbsp;</a></span>getCitiesC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string, <a class="el" href="classCity.html">City</a> * &gt; DataManip::getCitiesC </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the map of cities by code. </p>
<dl class="section return"><dt>Returns</dt><dd>Map of cities by code. </dd></dl>

</div>
</div>
<a id="af1e556e30b43f2b3ce1013aae422a4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e556e30b43f2b3ce1013aae422a4ac">&#9670;&nbsp;</a></span>getCitiesN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string, <a class="el" href="classCity.html">City</a> * &gt; DataManip::getCitiesN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the map of cities by name. </p>
<dl class="section return"><dt>Returns</dt><dd>Map of cities by name. </dd></dl>

</div>
</div>
<a id="ab59818e3e118aac3bfaab48cee367c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59818e3e118aac3bfaab48cee367c17">&#9670;&nbsp;</a></span>getDeficit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataManip::getDeficit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate and display the deficit of water for each city. </p>
<p>This function computes the deficit of water for each city in the network by subtracting the actual flow of water from the city's demand. It then displays the deficit for each city along with its demand and actual flow.</p>
<p>@complexity The overall time complexity of this function is O(n), where n is the number of cities in the network. </p>

</div>
</div>
<a id="a07820ea9a44d26b482cae7d99d05116a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07820ea9a44d26b482cae7d99d05116a">&#9670;&nbsp;</a></span>getGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html">Graph</a> DataManip::getGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the graph representing connections between cities, stations, and reservoirs. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classGraph.html" title="Represents a graph.">Graph</a> representing connections. </dd></dl>

</div>
</div>
<a id="a45db5e2770f3abbbb8a27f0571b66818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45db5e2770f3abbbb8a27f0571b66818">&#9670;&nbsp;</a></span>getReservoirs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string, <a class="el" href="classReservoir.html">Reservoir</a> * &gt; DataManip::getReservoirs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the map of reservoirs. </p>
<dl class="section return"><dt>Returns</dt><dd>Map of reservoirs. </dd></dl>

</div>
</div>
<a id="a33b165cac80dfa4b0636b3ff2348efc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b165cac80dfa4b0636b3ff2348efc6">&#9670;&nbsp;</a></span>getStations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string, <a class="el" href="classStation.html">Station</a> * &gt; DataManip::getStations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the map of stations. </p>
<dl class="section return"><dt>Returns</dt><dd>Map of stations. </dd></dl>

</div>
</div>
<a id="aa83fe0b71e04cce777e18d344bc93719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa83fe0b71e04cce777e18d344bc93719">&#9670;&nbsp;</a></span>maxFlowEdmonds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataManip::maxFlowEdmonds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the maximum flow in the graph using the Edmonds-Karp algorithm. </p>
<p>This function computes the maximum flow in the graph using the Edmonds-Karp algorithm. It first normalizes the graph by adding a super source and a super sink, then finds augmenting paths from the super source to the super sink repeatedly until no more augmenting paths exist. Along each augmenting path, it calculates the minimum residual capacity and augments the flow accordingly. After computing the maximum flow, it performs additional processing, such as updating flow values and removing the super source and super sink vertices from the graph.</p>
<p>@complexity The time complexity of this function is O(V * E^2), where V is the number of vertices and E is the number of edges in the graph. This complexity arises from the repeated execution of BFS to find augmenting paths, where each BFS has a complexity of O(V + E), and the maximum number of iterations of BFS is O(E) in the worst case. </p>

</div>
</div>
<a id="a70c7207186d8815be3027e57284a2e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c7207186d8815be3027e57284a2e52">&#9670;&nbsp;</a></span>maxFLowTotalCity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataManip::maxFLowTotalCity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>choose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>cityCodeOrName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate and display the maximum flow of water in the network, either total or for a specific city. </p>
<p>This function computes the maximum flow of water in the network using the Edmonds-Karp algorithm and then displays the result. It allows the user to choose between displaying the total maximum water flow for all cities or the maximum water flow for a specific city.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">choose</td><td>An integer indicating the user's choice: 0 for total maximum water flow, 1 for maximum water flow for a specific city. </td></tr>
    <tr><td class="paramname">cityCodeOrName</td><td>A string representing the city code or name for which the maximum water flow is to be calculated (relevant only when choose is 1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a732b3be343efce690f5f4b3a37150d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a732b3be343efce690f5f4b3a37150d">&#9670;&nbsp;</a></span>normalizeGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataManip::normalizeGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize the graph. </p>
<p>This function modifies the original graph by adding additional vertices and edges to create a normalized version of the graph for certain operations or analyses.</p>
<p>Specifically, it adds a super source vertex ("SS") and a super sink vertex ("SSK") to the graph, and connects the super source vertex to each reservoir with an edge representing its maximum delivery capacity, and connects each city to the super sink vertex with an edge representing its demand.</p>
<p>@complexity The overall time complexity of this function is O(r + c). </p>

</div>
</div>
<a id="ac61719284835fa07882cdaa2885a5171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61719284835fa07882cdaa2885a5171">&#9670;&nbsp;</a></span>pipelineRemoved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataManip::pipelineRemoved </td>
          <td>(</td>
          <td class="paramtype">vector&lt; pair&lt; string, string &gt;&gt;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulate the removal of pipelines. </p>
<p>This function simulates the effect of removing pipelines by setting the capacities of specified edges to zero. It recalculates the maximum flow in the network after adjusting the edge capacities. Then, it identifies cities affected by the removal based on the decrease in flow compared to the previous flow values. Finally, it restores the original capacities of the removed edges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>A vector containing pairs of strings representing the endpoints of the pipelines to be removed. Each pair represents a pipeline to be removed.</td></tr>
  </table>
  </dd>
</dl>
<p>@complexity The time complexity of this function depends on the number of cities and edges in the respective maps. The function performs an iteration over the citiesC_ map to store and restore flow values, resulting in linear-time complexity with respect to the number of cities. It also performs operations on edges connected to the removed pipelines, which have a constant-time complexity within the loop, resulting in linear-time complexity with respect to the number of edges affected. Therefore, the overall time complexity of this function is O(V * E^2). </p>

</div>
</div>
<a id="a7ae69424dd271f8b1e42ad8249d782f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae69424dd271f8b1e42ad8249d782f2">&#9670;&nbsp;</a></span>reservoirOutOfCommission()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataManip::reservoirOutOfCommission </td>
          <td>(</td>
          <td class="paramtype">vector&lt; string &gt;&#160;</td>
          <td class="paramname"><em>codeOrName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulate the removal of reservoirs from commission. </p>
<p>This function simulates the effect of removing reservoirs from commission by setting their maximum delivery to zero. It recalculates the maximum flow in the network after adjusting the reservoirs' maximum delivery values. Then, it identifies cities affected by the removal based on the decrease in flow compared to the previous flow values. Finally, it restores the original maximum delivery values of the removed reservoirs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>A vector containing the codes or names of reservoirs to be removed from commission.</td></tr>
  </table>
  </dd>
</dl>
<p>@complexity The time complexity of this function depends on the number of cities and reservoirs in the respective maps. The function performs two iterations over the citiesC_ map to store and restore flow values, resulting in linear-time complexity with respect to the number of cities. It also performs operations on reservoirs, which have a constant-time complexity within the loop, resulting in linear-time complexity with respect to the number of reservoirs. Therefore, the overall time complexity of this function is O(V * E^2). </p>

</div>
</div>
<a id="ac3c06df80ae7332913f1b4fb6836ba76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c06df80ae7332913f1b4fb6836ba76">&#9670;&nbsp;</a></span>testAndVisit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataManip::testAndVisit </td>
          <td>(</td>
          <td class="paramtype">queue&lt; <a class="el" href="classVertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>residual</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test and visit a vertex. </p>
<p>This function tests whether the vertex 'w' has been visited before and if the residual capacity of the edge 'e' to 'w' is greater than 0. If 'w' has not been visited and the residual capacity is positive, 'w' is marked as visited, its path through which it was reached is set, and it is enqueued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue to enqueue 'w' if it meets the conditions. </td></tr>
    <tr><td class="paramname">e</td><td>The edge through which 'w' is reached. </td></tr>
    <tr><td class="paramname">w</td><td>The vertex to test and visit. </td></tr>
    <tr><td class="paramname">residual</td><td>The residual capacity of the edge 'e' to 'w'.</td></tr>
  </table>
  </dd>
</dl>
<p>@complexity The time complexity of this function is O(1) as it performs a constant number of operations regardless of the input size. </p>

</div>
</div>
<a id="a49f72542e61a848e805e9facdaced082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f72542e61a848e805e9facdaced082">&#9670;&nbsp;</a></span>verifyCityCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string DataManip::verifyCityCode </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>cityCodeOrName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify city code or name. </p>
<p>This function verifies if the given cityNameOrCode is a code or a name of the city. If it's the name its corresponding code is returned. If it's the code, input cityNameOrCode is returned unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cityNameOrCode</td><td>The name or code of the city to verify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The city code. </dd></dl>

</div>
</div>
<a id="a87a496e4c5a426566b0b73c772ce3f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a496e4c5a426566b0b73c772ce3f04">&#9670;&nbsp;</a></span>verifyReservoirCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string DataManip::verifyReservoirCode </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>reservoirNameOrCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify city code or name. </p>
<p>This function verifies if the given cityNameOrCode is a code or a name of the city. If it's the name, its corresponding code is returned. If it's the code, input cityNameOrCode is returned unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cityNameOrCode</td><td>The name or code of the city to verify. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The city code. If the input is already a code, it is returned unchanged. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="DataManip_8h_source.html">DataManip.h</a></li>
<li>src/DataManip.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
